{"version":3,"sources":["../src/client.ts","../src/utils.ts","../src/function-types.ts","../src/index.ts"],"sourcesContent":["import { ChatFunctionCall, ChatText, ChatFunctionReturn } from './message.js';\n\nfunction checkResponse(r: Response): Promise<unknown> {\n  if (!r.ok) {\n    throw Error(`Request ${r.url} failed with ${r.status}: ${r.statusText}`);\n  }\n  if (r.status === 204) {\n    return Promise.resolve();\n  }\n  return r.json();\n}\n\nfunction throwOnApiError<T>(json: T): T {\n  // Check service unavailable message\n  if ((json as any)?.message === 'Service Unavailable') {\n    throw Error((json as any).message);\n  }\n  // Pass through otherwise\n  return json;\n}\n\nfunction unwrapApi(json: any): unknown {\n  // If there is a body, return that instead\n  if (json?.body\n    && typeof json.body === 'string'\n    && json.body.startsWith('{')\n    && json.body.endsWith('}')\n  ) {\n    return JSON.parse(json.body);\n  }\n  return json;\n}\n\nfunction parseIudexResponse(r: Response): Promise<any> {\n  return checkResponse(r)\n    .then(throwOnApiError)\n    .then(unwrapApi)\n    .catch((e) => {\n      throw Error(`Request ${r.url} failed with ${r.status}: ${e.message}`);\n    });\n}\n\n// TODO change to putFunctionCallReturn to better match api def name\nexport type ReturnFunctionCallBody = Pick<ChatFunctionReturn, 'functionCallId'|'functionReturn'>;\nexport type ReturnFunctionCallRes = { workflowId: string; message: string; };\nexport function returnFunctionCall(baseUrl: string, apiKey: string) {\n  return function (functionCallId: string, functionReturn: string): Promise<void> {\n    const bodyJson: ReturnFunctionCallBody = {\n      functionCallId,\n      functionReturn,\n    };\n    return fetch(baseUrl + '/function_calls/' + functionCallId + '/return', {\n      method: 'PUT',\n      headers: { 'x-api-key': `${apiKey}` },\n      body: JSON.stringify(bodyJson),\n    }).then(parseIudexResponse);\n  };\n}\n\nexport type NextMessageRes = ChatFunctionCall | ChatText | undefined;\nexport function nextMessage(baseUrl: string, apiKey: string) {\n  return function (workflowId: string): Promise<NextMessageRes> {\n    return fetch(baseUrl + '/workflows/' + workflowId + '/next_message', {\n      method: 'GET',\n      headers: { 'x-api-key': `${apiKey}` },\n    }).then(parseIudexResponse);\n  };\n}\n\n// TODO change to postWorkflows to better match api def name\nexport type StartWorkflowRes = { workflowId: string; message: string; };\nexport function startWorkflow(baseUrl: string, apiKey: string) {\n  return function (query: string, modules?: string): Promise<StartWorkflowRes> {\n    return fetch(baseUrl + '/workflows', {\n      method: 'POST',\n      headers: { 'x-api-key': `${apiKey}` },\n      body: JSON.stringify({ query, modules }),\n    }).then(parseIudexResponse);\n  };\n}\n\n\ntype FunctionJson = {\n  name: string;\n  description?: string;\n  parameters?: Record<string, any>;\n  returns?: Record<string, any>;\n  usageExample?: string;\n  returnsExample?: string;\n};\nexport type putFunctionJsonsReq = { jsons: FunctionJson[]; module?: string; };\nexport function putFunctionJsons(baseUrl: string, apiKey: string) {\n  return function (jsons: FunctionJson[], module?: string): Promise<void> {\n    const bodyJson: putFunctionJsonsReq = { jsons, module };\n    return fetch(baseUrl + '/function_jsons', {\n      method: 'PUT',\n      headers: { 'x-api-key': `${apiKey}` },\n      body: JSON.stringify(bodyJson),\n    }).then(parseIudexResponse);\n  };\n}\n","export function setTimeoutPromise(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport function poll<Args extends any[], Ret>(\n  fn: (...args: Args) => Promise<Ret>,\n  args: Args,\n  {\n    maxTries,\n    tries,\n    waitMs,\n  }: {\n    maxTries: number;\n    tries: number;\n    waitMs: number;\n  } = { maxTries: 300, tries: 0, waitMs: 1000 },\n): Promise<NonNullable<Ret>> {\n  if (tries >= maxTries) {\n    throw Error(\n      `Polling failed after ${maxTries} tries for function ${fn.name}.`,\n    );\n  }\n  return fn(...args).then(res => {\n    if (res == null) {\n      return setTimeoutPromise(waitMs)\n        .then(() => poll(fn, args, { maxTries, tries: tries + 1, waitMs }));\n    }\n    return res;\n  });\n}\n","import { z } from 'zod';\n\n/**\n * Recursive JSON object schema\n */\nexport type ObjectJsonSchema = {\n  type: 'object',\n  properties: Record<string, ValueJsonSchema>,\n  description?: string;\n}\nconst objectJsonSchema: z.ZodType<ObjectJsonSchema> = z.object({\n  type: z.literal('object'),\n  properties: z.record(z.lazy(() => valueJsonSchema)),\n  description: z.string().optional(),\n  required: z.array(z.string()).optional(),\n});\n\ntype RecordJsonSchema = {\n  type: 'object',\n  additionalProperties: ValueJsonSchema,\n  description?: string;\n}\nconst recordJsonSchema: z.ZodType<RecordJsonSchema> = z.object({\n  type: z.literal('object'),\n  additionalProperties: z.lazy(() => valueJsonSchema),\n  description: z.string().optional(),\n});\n\ntype ArrayJsonSchema = {\n  type: 'array',\n  items: ValueJsonSchema,\n  description?: string;\n}\nconst arrayJsonSchema: z.ZodType<ArrayJsonSchema>  = z.object({\n  type: z.literal('array'),\n  items: z.lazy(() => valueJsonSchema),\n  description: z.string().optional(),\n});\n\nconst tupleJsonSchema = z.object({\n  type: z.literal('array'),\n  prefixItems: z.array(z.string()),\n  description: z.string().optional(),\n});\n\nconst stringJsonSchema = z.object({\n  type: z.literal('string'),\n  enum: z.array(z.string()).optional(),\n  description: z.string().optional(),\n});\n\nconst numberJsonSchema = z.object({\n  type: z.union([z.literal('number'), z.literal('integer')]),\n  description: z.string().optional(),\n  minimum: z.number().optional(),\n  maximum: z.number().optional(),\n});\n\nconst booleanJsonSchema = z.object({\n  type: z.literal('boolean'),\n  description: z.string().optional(),\n});\n\n/**\n * This is not the real way to represent union types in JSON Schema.\n * The real way sucks.\n */\nconst unionJsonSchema = z.object({\n  type: z.array(z.string()),\n  description: z.string().optional(),\n});\n\ntype RealUnionJsonSchema = {\n  anyOf: ValueJsonSchema[],\n  description?: string;\n}\n/**\n * The real way to represent unions\n */\nconst realUnionJsonSchema: z.ZodType<RealUnionJsonSchema>  = z.object({\n  anyOf: z.array(z.lazy(() => valueJsonSchema)),\n  description: z.string().optional(),\n});\n\nconst unknownJsonSchema = z.object({\n  type: z.literal('unknown'),\n  description: z.string().optional(),\n});\n\nconst nullJsonSchema = z.object({\n  type: z.literal('null'),\n  description: z.string().optional(),\n});\n\nconst refJsonSchema = z.object({\n  $ref: z.string(),\n  description: z.string().optional(),\n});\n\nconst valueJsonSchema = z.union([\n  objectJsonSchema,\n  recordJsonSchema,\n  arrayJsonSchema,\n  tupleJsonSchema,\n  stringJsonSchema,\n  numberJsonSchema,\n  booleanJsonSchema,\n  unionJsonSchema,\n  realUnionJsonSchema,\n  unknownJsonSchema,\n  nullJsonSchema,\n  refJsonSchema,\n]);\nexport type ValueJsonSchema = z.infer<typeof valueJsonSchema>;\n\n/**\n * OpenAI function json schema\n */\nexport const functionJsonSchema = z.object({\n  name: z.string(),\n  description: z.string(),\n  parameters: z.union([\n    z.object({\n      type: z.literal('object'),\n      properties: z.record(valueJsonSchema),\n      description: z.string().optional(),\n      required: z.array(z.string()).optional(),\n    }),\n    z.array(valueJsonSchema),\n  ]),\n  returns: valueJsonSchema,\n  usageExample: z.string().optional(),\n  returnsExample: z.string().optional(),\n});\nexport type FunctionJson = z.infer<typeof functionJsonSchema>;\n\nexport const nullFunctionJson: FunctionJson = {\n  name: '',\n  description: '',\n  parameters: [],\n  returns: { type: 'null' },\n};\n","import OpenAI from 'openai';\nimport { ChatFunctionReturn, ChatText, ChatTurn } from './message.js';\nimport * as client from './client.js';\nexport * from './client.js';\nimport { poll } from './utils.js';\nimport { FunctionJson } from './function-types.js';\nexport * from './function-types.js';\n\nexport const DEFAULT_BASE_URL = 'https://api.iudex.ai';\n\nexport type IudexMessage = ChatTurn;\n\nexport type ChatCompletionMessageWithIudex = OpenAI.ChatCompletionMessageParam & ({\n  tool_call_id?: string;\n  workflowId?: string;\n} | {\n  tool_call_id: string;\n  workflowId: string;\n});\n\nexport type ChatCompletionWithIudex = OpenAI.ChatCompletion & {\n  choices: Array<OpenAI.ChatCompletion.Choice & {\n    message: OpenAI.ChatCompletionMessage & { workflowId: string; };\n  }>\n};\n\n/**\n * Iudex api client.\n */\nexport class Iudex {\n  baseUrl: string;\n  apiKey: string;\n  functionLinker?: (fnName: string) => (...args: any[]) => unknown;\n\n  constructor({\n    apiKey = process.env.IUDEX_API_KEY,\n    baseUrl = process.env.IUDEX_BASE_URL || DEFAULT_BASE_URL,\n  }: {\n    apiKey?: string;\n    baseUrl?: string;\n  } = {\n    apiKey: process.env.IUDEX_API_KEY,\n    baseUrl: DEFAULT_BASE_URL,\n  }) {\n    if (!apiKey) {\n      throw Error(\n        `The IUDEX_API_KEY environment variable is missing or empty.` +\n        ` Provide IUDEX_API_KEY to the environment on load` +\n        ` OR instantiate the Iudex client with the apiKey option.` +\n        ` Example: \\`new Iudex({ apiKey: 'My API Key' })\\``,\n      );\n    }\n    this.apiKey = apiKey;\n    this.baseUrl = baseUrl;\n  }\n\n  uploadFunctions = (\n    jsons: Array<OpenAI.ChatCompletionCreateParams.Function | FunctionJson>,\n    modules?: string,\n  ): Promise<void> => {\n    return client.putFunctionJsons(this.baseUrl, this.apiKey)(jsons, modules);\n  };\n\n  linkFunctions = (functionLinker: (fnName: string) => (...args: any[]) => unknown): void => {\n    this.functionLinker = functionLinker;\n  };\n\n  /**\n   * @param message message to send\n   * @returns response as a chat object\n   */\n  sendChatTurn = async (\n    message: string,\n    opts: { onChatTurn?: (c: ChatTurn) => void} = {},\n  ): Promise<ChatText> => {\n    const { onChatTurn } = opts;\n\n    const userTurn: ChatText = {\n      id: 'msg_ephemeral_' + new Date().toISOString(),\n      type: 'text',\n      sender: 'you',\n      timestamp: new Date().toISOString(),\n      text: message,\n    };\n    onChatTurn?.(userTurn);\n    const { workflowId } = await client.startWorkflow(this.baseUrl, this.apiKey)(userTurn.text);\n\n    let nextMessage = await poll(client.nextMessage(this.baseUrl, this.apiKey), [workflowId]);\n    onChatTurn?.(nextMessage);\n\n    while (nextMessage.type === 'functionCall') {\n      if (!this.functionLinker) {\n        throw Error(\n          'Establish a way to call functions using `.linkFunctions` before' +\n          ' sending a message that might require your functions to answer.',\n        );\n      }\n      const fn = this.functionLinker(nextMessage.functionName);\n      const fnReturn = await fn(nextMessage.functionArgs);\n\n      const fnReturnTurn: ChatFunctionReturn = {\n        id: 'msg_ephemeral_' + new Date().toISOString(),\n        type: 'functionReturn',\n        sender: nextMessage.functionName,\n        timestamp: new Date().toISOString(),\n        functionCallId: nextMessage.functionCallId,\n        functionReturn: JSON.stringify(fnReturn),\n      };\n      onChatTurn?.(fnReturnTurn);\n      await client.returnFunctionCall(this.baseUrl, this.apiKey)(\n        fnReturnTurn.functionCallId,\n        fnReturnTurn.functionReturn,\n      );\n\n      nextMessage = await poll(client.nextMessage(this.baseUrl, this.apiKey), [workflowId]);\n      onChatTurn?.(nextMessage);\n    }\n\n    return nextMessage;\n  };\n\n  /**\n   * @param message message to send\n   * @returns response message as a string\n   */\n  sendMessage = async (message: string): Promise<string> => {\n    const chatTurn = await this.sendChatTurn(message);\n    return chatTurn.text;\n  };\n\n  // OpenAI interface shim\n  chatCompletionsCreate = (body: OpenAI.ChatCompletionCreateParamsNonStreaming & {\n    messages: Array<ChatCompletionMessageWithIudex>\n  }): Promise<ChatCompletionWithIudex>  => {\n    const lastMessage = body.messages[body.messages.length - 1];\n    if (!lastMessage) {\n      throw Error(`The messages array is empty.`);\n    }\n\n    // Expecting the last message to be the function result or a new query.\n    // So, the second to last message is the previous Iudex message with\n    // the function to call + callId or is undefined.\n    const penUltMessage = body.messages[body.messages.length - 2];\n\n    // If there is a tool_call_id, we use it to continue the execution in Iudex\n    if (lastMessage?.tool_call_id && penUltMessage?.workflowId) {\n      const workflowId = penUltMessage.workflowId;\n      const callId = lastMessage.tool_call_id;\n      const functionReturn = lastMessage.content || '';\n\n      // Put data\n      const functionCallRes =\n        client.returnFunctionCall(this.baseUrl, this.apiKey)(callId, String(functionReturn));\n\n      // Wait for new message\n      const nextMessageRes = functionCallRes\n        .then(() => poll(client.nextMessage(this.baseUrl, this.apiKey), [workflowId]));\n\n      // Return result as OpenAI.ChatCompletion\n      return nextMessageRes.then((r) => {\n        return {\n          model: body.model,\n          ...mapIudexToOpenAi(r, workflowId),\n        };\n      });\n    }\n\n    if (!lastMessage.content) {\n      throw Error(`The message content is empty.`);\n    }\n\n    // Else create new workflow\n    const messageContent = extractMessageTextContent(lastMessage.content);\n    return client.startWorkflow(this.baseUrl, this.apiKey)(messageContent)\n      .then(({ workflowId }) =>\n        poll(client.nextMessage(this.baseUrl, this.apiKey), [workflowId])\n          .then((r) => {\n            return {\n              model: body.model,\n              ...mapIudexToOpenAi(r, workflowId),\n            };\n          }),\n      );\n  };\n\n  chat = {\n    completions: {\n      create: this.chatCompletionsCreate,\n    },\n  };\n}\n\n/**\n * Maps IudexMessage to OpenAI.ChatCompletion.\n */\nexport function mapIudexToOpenAi(\n  m: IudexMessage,\n  workflowId: string,\n): Omit<ChatCompletionWithIudex, 'model'> {\n  // If the result is a function_call, we return the function call\n  if (m.type === 'functionCall') {\n    const message = {\n      content: null,\n      role: 'assistant' as const,\n      tool_calls: [{\n        id: m.functionCallId,\n        function: { name: m.functionName, arguments: JSON.stringify(m.functionArgs) },\n        type: 'function' as const,\n      }],\n      workflowId,\n    };\n    return {\n      id: m.id,\n      choices: [{\n        index: 0,\n        finish_reason: 'tool_calls',\n        logprobs: null,\n        message,\n      }],\n      created: new Date(m.timestamp).valueOf(),\n      object: 'chat.completion',\n    };\n  }\n\n  // Else assume it's the final result\n  if (m.type === 'text') {\n    const message = {\n      content: m.text,\n      role: 'assistant' as const,\n      workflowId,\n    };\n    return {\n      id: m.id,\n      choices: [{\n        index: 0,\n        finish_reason: 'stop',\n        logprobs: null,\n        message,\n      }],\n      created: new Date(m.timestamp).valueOf(),\n      object: 'chat.completion',\n    };\n  }\n\n  throw Error('Unsupported message type: ' + m.type);\n}\n\n/**\n * Extracts OpenAI message content as a string.\n */\nexport function extractMessageTextContent(\n  content: OpenAI.ChatCompletionUserMessageParam['content'],\n): string {\n  if (typeof content === 'string') {\n    return content;\n  }\n  // Else content is array containing PartImage or PartText\n  return content.map(c => c.type === 'text' ? c.text : '').join('');\n}\n\nexport default Iudex;\n"],"mappings":"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","names":["nextMessage"]}