{"version":3,"sources":["../src/index.ts","../src/client.ts","../src/utils.ts"],"sourcesContent":["import OpenAI from 'openai';\nimport { ChatTurn } from './message.js';\nimport * as client from './client.js';\nexport * from './client.js';\nimport { poll } from './utils.js';\n\nexport const DEFAULT_BASE_URL = 'https://5pz08znmzj.execute-api.us-west-2.amazonaws.com';\n\nexport type IudexMessage = ChatTurn;\n\nexport type ChatCompletionMessageWithIudex = OpenAI.ChatCompletionMessageParam & ({\n  tool_call_id?: string;\n  workflowId?: string;\n} | {\n  tool_call_id: string;\n  workflowId: string;\n});\n\nexport type ChatCompletionWithIudex = OpenAI.ChatCompletion & {\n  choices: Array<OpenAI.ChatCompletion.Choice & {\n    message: OpenAI.ChatCompletionMessage & { workflowId: string; };\n  }>\n};\n\n/**\n * Iudex api client.\n */\nexport class Iudex {\n  baseUrl: string;\n  apiKey: string;\n\n  constructor({\n    apiKey = process.env.IUDEX_API_KEY,\n    baseUrl = process.env.IUDEX_BASE_URL || DEFAULT_BASE_URL,\n  }: {\n    apiKey?: string;\n    baseUrl?: string;\n  } = {\n    apiKey: process.env.IUDEX_API_KEY,\n    baseUrl: DEFAULT_BASE_URL,\n  }) {\n    if (!apiKey) {\n      throw Error(\n        `The IUDEX_API_KEY environment variable is missing or empty.` +\n        ` Provide IUDEX_API_KEY to the environment on load` +\n        ` OR instantiate the Iudex client with the apiKey option.` +\n        ` Example: \\`new Iudex({ apiKey: 'My API Key' })\\``,\n      );\n    }\n    this.apiKey = apiKey;\n    this.baseUrl = baseUrl;\n  }\n\n  uploadFunctions = (\n    jsons: Array<OpenAI.ChatCompletionCreateParams.Function>,\n    modules?: string,\n  ): Promise<void> => {\n    return client.putFunctionJsons(this.baseUrl, this.apiKey)(jsons, modules);\n  };\n\n  // OpenAI interface shim\n  chatCompletionsCreate = (body: OpenAI.ChatCompletionCreateParamsNonStreaming & {\n    messages: Array<ChatCompletionMessageWithIudex>\n  }): Promise<ChatCompletionWithIudex>  => {\n    const lastMessage = body.messages[body.messages.length - 1];\n    if (!lastMessage) {\n      throw Error(`The messages array is empty.`);\n    }\n\n    // Expecting the last message to be the function result or a new query.\n    // So, the second to last message is the previous Iudex message with\n    // the function to call + callId or is undefined.\n    const penUltMessage = body.messages[body.messages.length - 2];\n\n    // If there is a tool_call_id, we use it to continue the execution in Iudex\n    if (lastMessage?.tool_call_id && penUltMessage?.workflowId) {\n      const workflowId = penUltMessage.workflowId;\n      const callId = lastMessage.tool_call_id;\n      const functionReturn = lastMessage.content;\n\n      // Put data\n      const functionCallRes =\n        client.returnFunctionCall(this.baseUrl, this.apiKey)(callId, functionReturn);\n\n      // Wait for new message\n      const nextMessageRes = functionCallRes\n        .then(() => poll(client.nextMessage(this.baseUrl, this.apiKey), [workflowId]));\n\n      // Return result as OpenAI.ChatCompletion\n      return nextMessageRes.then((r) => {\n        return {\n          model: body.model,\n          ...mapIudexToOpenAi(r, workflowId),\n        };\n      });\n    }\n\n    if (!lastMessage.content) {\n      throw Error(`The message content is empty.`);\n    }\n\n    // Else create new workflow\n    const messageContent = extractMessageTextContent(lastMessage.content);\n    return client.startWorkflow(this.baseUrl, this.apiKey)(messageContent)\n      .then(({ workflowId }) =>\n        poll(client.nextMessage(this.baseUrl, this.apiKey), [workflowId])\n          .then((r) => {\n            return {\n              model: body.model,\n              ...mapIudexToOpenAi(r, workflowId),\n            };\n          }),\n      );\n  };\n\n  chat = {\n    completions: {\n      create: this.chatCompletionsCreate,\n    },\n  };\n}\n\n/**\n * Maps IudexMessage to OpenAI.ChatCompletion.\n */\nexport function mapIudexToOpenAi(\n  m: IudexMessage,\n  workflowId: string,\n): Omit<ChatCompletionWithIudex, 'model'> {\n  // If the result is a function_call, we return the function call\n  if (m.type === 'functionCall') {\n    const message = {\n      content: null,\n      role: 'assistant' as const,\n      tool_calls: [{\n        id: m.functionCallId,\n        function: { name: m.functionName, arguments: JSON.stringify(m.functionArgs) },\n        type: 'function' as const,\n      }],\n      workflowId,\n    };\n    return {\n      id: m.id,\n      choices: [{\n        index: 0,\n        finish_reason: 'tool_calls',\n        logprobs: null,\n        message,\n      }],\n      created: new Date(m.timestamp).valueOf(),\n      object: 'chat.completion',\n    };\n  }\n\n  // Else assume it's the final result\n  if (m.type === 'text') {\n    const message = {\n      content: m.text,\n      role: 'assistant' as const,\n      workflowId,\n    };\n    return {\n      id: m.id,\n      choices: [{\n        index: 0,\n        finish_reason: 'stop',\n        logprobs: null,\n        message,\n      }],\n      created: new Date(m.timestamp).valueOf(),\n      object: 'chat.completion',\n    };\n  }\n\n  throw Error('Unsupported message type: ' + m.type);\n}\n\n/**\n * Extracts OpenAI message content as a string.\n */\nexport function extractMessageTextContent(\n  content: OpenAI.ChatCompletionUserMessageParam['content'],\n): string {\n  if (typeof content === 'string') {\n    return content;\n  }\n  // Else content is array containing PartImage or PartText\n  return content.map(c => c.type === 'text' ? c.text : '').join('');\n}\n\nexport default Iudex;\n","import { ChatFunctionCall, ChatText, ChatFunctionReturn } from './message.js';\n\nfunction checkResponse(r: Response): Response {\n  if (!r.ok) {\n    throw Error(`Request ${r.url} failed with ${r.status}: ${r.statusText}`);\n  }\n  return r;\n}\n\nfunction throwOnApiError<T>(json: T): T {\n  // Check service unavailable message\n  if ((json as any)?.message === 'Service Unavailable') {\n    throw Error((json as any).message);\n  }\n  // Pass through otherwise\n  return json;\n}\n\nfunction unwrapApi(json: any): any {\n  // If there is a body, return that instead\n  if (json?.body\n    && typeof json.body === 'string'\n    && json.body.startsWith('{')\n    && json.body.endsWith('}')\n  ) {\n    return JSON.parse(json.body);\n  }\n  return json;\n}\n\nfunction parseIudexResponse(r: Response): Promise<any> {\n  return checkResponse(r).json().then(throwOnApiError).then(unwrapApi).catch((e) => {\n    throw Error(`Request ${r.url} failed with ${r.status}: ${e.message}`);\n  });\n}\n\n// TODO change to putFunctionCallReturn to better match api def name\nexport type ReturnFunctionCallBody = Pick<ChatFunctionReturn, 'functionCallId'|'functionReturn'>;\nexport type ReturnFunctionCallRes = { workflowId: string; message: string; };\nexport function returnFunctionCall(baseUrl: string, apiKey: string) {\n  return function (functionCallId: string, functionReturn: any): Promise<void> {\n    const bodyJson: ReturnFunctionCallBody = {\n      functionCallId,\n      functionReturn: JSON.stringify(functionReturn),\n    };\n    return fetch(baseUrl + '/function_calls/' + functionCallId + '/return', {\n      method: 'PUT',\n      headers: { 'x-api-key': `${apiKey}` },\n      body: JSON.stringify(bodyJson),\n    }).then(parseIudexResponse);\n  };\n}\n\nexport type NextMessageRes = ChatFunctionCall | ChatText | undefined;\nexport function nextMessage(baseUrl: string, apiKey: string) {\n  return function (workflowId: string): Promise<NextMessageRes> {\n    return fetch(baseUrl + '/workflows/' + workflowId + '/next_message', {\n      method: 'GET',\n      headers: { 'x-api-key': `${apiKey}` },\n    }).then(parseIudexResponse);\n  };\n}\n\n// TODO change to postWorkflows to better match api def name\nexport type StartWorkflowRes = { workflowId: string; message: string; };\nexport function startWorkflow(baseUrl: string, apiKey: string) {\n  return function (query: string, modules?: string): Promise<StartWorkflowRes> {\n    return fetch(baseUrl + '/workflows', {\n      method: 'POST',\n      headers: { 'x-api-key': `${apiKey}` },\n      body: JSON.stringify({ query, modules }),\n    }).then(parseIudexResponse);\n  };\n}\n\n\ntype FunctionJson = {\n  name: string;\n  description?: string;\n  parameters?: Record<string, any>;\n  returns?: Record<string, any>;\n  usageExample?: string;\n  returnsExample?: string;\n};\nexport type putFunctionJsonsReq = { jsons: FunctionJson[]; module?: string; };\nexport function putFunctionJsons(baseUrl: string, apiKey: string) {\n  return function (jsons: FunctionJson[], module?: string): Promise<void> {\n    const bodyJson: putFunctionJsonsReq = { jsons, module };\n    return fetch(baseUrl + '/function_jsons', {\n      method: 'PUT',\n      headers: { 'x-api-key': `${apiKey}` },\n      body: JSON.stringify(bodyJson),\n    }).then(parseIudexResponse);\n  };\n}\n","export function setTimeoutPromise(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport function poll<Args extends any[], Ret>(\n  fn: (...args: Args) => Promise<Ret>,\n  args: Args,\n  {\n    maxTries,\n    tries,\n    waitMs,\n  }: {\n    maxTries: number;\n    tries: number;\n    waitMs: number;\n  } = { maxTries: 300, tries: 0, waitMs: 1000 },\n): Promise<NonNullable<Ret>> {\n  if (tries >= maxTries) {\n    throw Error(\n      `Polling failed after ${maxTries} tries for function ${fn.name}.`,\n    );\n  }\n  return fn(...args).then(res => {\n    if (res == null) {\n      return setTimeoutPromise(waitMs)\n        .then(() => poll(fn, args, { maxTries, tries: tries + 1, waitMs }));\n    }\n    return res;\n  });\n}\n"],"mappings":"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","names":["module"]}